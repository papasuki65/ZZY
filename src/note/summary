1.  C++头文件路径 /usr/include/9/c++
    C++stl实现路径 /usr/include/9/c++/bits

2.  make_shared构造后返回一个shared_ptr指针，之后调用shared_ptr的移动拷贝构造
    直接使用shared_ptr参数构造时，先生成一个临时变量，之后在shared_ptr构造里需要调用放入指针的class类型支持移动拷贝语义，否则会调用其拷贝构造。

3.  g++ -E(预处理) -S(词法、语法解析，为编译节点生成汇编代码文件) -c(汇编，将生成的汇编码)
    目标文件就是源代码经过编译后但未进行链接的那些中间文件Linux下的 .o文件就是目标文件，目标文件和可执行文件内容和格式几乎都一样，
    所以我们可以广义地将目标文件和可执行文化看成一类型文件。他们都是按照ELF文件格式存储的

    Linux下.o文件、可执行文件、核心转储文件(core dump)、.so文件(动态链链接库）都是ELF类型文件
    file xxx.o可以看到文件信息，[not stripped]代表没有丢掉符号表，可以用strip xxx.o手动丢弃符号表
    readelf [-s] [xxx.o] 查看符号表
    objdump [-h] [xxx.o]

4.  FlameGraph使用: sudo perf record -F 99 -p [pid] -g -- sleep 10  // perf record表示采集系统事件。没有使用-e指定采集事件，则默认采集cycle（即CPU clock周期）
                    sudo perf record -g -F 99 -- {command}        //-F 采样频率 -g 记录调用栈 sleep 持续10秒
                    perf script -i perf.data &> perf.unfold                     //生成折叠后的调用栈(可以vim直接查看)
                    FlameGraph/stackcollapse-perf.pl perf.unfold &> perf.fold   //将perf解析出的内容中的符号进行折叠(可以vim直接查看)
                    FlameGraph/flamegraph.pl perf.fold > process.svg            //生成svg图

5.  clang -Xclang -fdump-record-layouts -stdlib=libc++ -std=c++11 -c oop.cc     //查看对象布局
    clang -Xclang -fdump-vtable-layouts -stdlib=libc++ -std=c++11 -c oop.cc     //查看虚函数布局

